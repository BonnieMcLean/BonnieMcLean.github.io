---
title: "Introduction to RStudio"
author: "Bonnie McLean"
date: "`r Sys.Date()`"
output:
  html_notebook:
    code_folding: show
    number_sections: yes
    toc: yes
    toc_float: true
---

# Outputs

You can create many different outputs in RStudio. The output we are using is a `html_notebook`. 

Other popular outputs are `html_document`, `pdf_document`, `word_document`. You can use the 'knit to PDF, knit to word, knit to html etc.' buttons to change your output.

For PDF output, you need to have LaTex installed. If you use Windows, [MikTex](https://miktex.org/download) will install a basic LaTex system. If you use mac, you can install [MacTex](https://tug.org/mactex/).

The html document, pdf document and word document formats are good for when you have something finished that you want to publish. As you are still working on a project, the `html_notebook` format is more convenient, because it lets you quickly generate the document without needing to rerun every code chunk from the top.

When you press 'preview' on a html notebook, it only shows the output for code that was run in that R session, from the last time it was run. So if you ever press 'preview' and are wondering why you don't see any output for some code, it's probably because you haven't run it in your R session yet.

# Markdown

You can try markdown live [here](https://stackedit.io/app#)

# A new section

When you have `number_sections: yes` beneath your `html_notebook` in the YAML header (the stuff at the top of your R notebook), the sections will be numbered.

## A sub-section

Sub-section text.

### A sub-sub section

Sub-sub section text.

# Writing in Markdown

Regular text  
**Bold text**  
*Italicised text*  

You need to use two spaces at the end of the line if you want things to appear on separate lines.

Different paragraphs should have a full empty line in between.

**Lists**:

* point
* another point
  - sub point
    - sub sub point
* another point

**Ordered lists**:

1. First
2. Second
3. Third
3. Fourth

**Links**

Hyperlinks are created like [this](https://bookdown.org/yihui/rmarkdown/markdown-syntax.html)

Follow the hyperlink above to learn more about how to type stuff in markdown! (Including e.g. tables, math, block quotes, etc.)

**Images**

Images generated by R just appear when you run your R code chunk. But if you want to include external images, you can do it like this:

![A picture of my dog](images\coco.jpg){width=25%}

**Footnotes**

You can insert footnotes like this^[But try to avoid using footnotes in general]

**Inline code**

If you want to reference package names etc. and have it appear like code, you can use backticks, e.g. `mypackage`.


# Code chunks

Press ctrl+alt+I (windows)/command+option+I (mac) to insert a chunk of R code. 

```{r printmessage}
print('This is a chunk of R code')
```

Code chunks in your notebook need to have unique names.

It's a good rule of thumb to use one code chunk per task, and name the code chunk with something that tells you what task it does.

# Basic Math

You can use R just like a calculater, to do addition...

```{r addition}
2+2
```

... subtraction ...

```{r subtraction}
3-2
```

... multiplication ... 

```{r multiplication}
3*2
```

... division... 

```{r division}
1/3
```

... and more, just remember to use brackets where needed!

```{r brackets}
(2*4)/(3*3)==2*4/3*3
```

The first is 8/9, the second is (8/3)*3.


When we use two equal signs, we are asking R a question. `X==Y` means *does X equal Y*? To ask the opposite question, use `!=`

```{r conditions}
(2*4)/(3*3)!=2*4/3*3
```

A single = sign in R is used for *variable assignment*.


# Variables and basic data types

A *variable* is a named container that we can store values in.

*Variable assignment* is when we assign a value to a variable, so that we can retrieve that value later by using the variables name. Assignment can be done with the equal sign (=) or with an arrow `<-`. An arrow is most common. Type `Alt` and `-` (or `Cmd` and `-` on Mac) to get `<-`

**Assignment (setting a variable to refer to a value)**
```{r assign}
a <- 5
```
The variable remains in the environment, so you can use it again:

```{r use}
a + 3
```

But don't forget that if you change it in one chunk of R code, you have to re-run every previous code block that used it if you want the results to reflect the new value (use 'Run all chunks above' instead of just 'run')

```{r reassign}
a<-7
a + 3
```


**Character variables**

```{r char}
lang <- "Russian"
lang
```

Try this yourself 
```{r adding num and char}
a + lang
```

You cannot add together two variables of different types (numbers and characters).

Use the function `str()` to get information about the structure of an R variable, including its type.

```{r variable_info}
str(a)
str(lang)
```


Numbers can be characters, but only in quotes
```{r}
a <- "99"
a
```

But you still can't add numbers to characters.

```{r}
a + 1
```

You also can't use "+" with two characters:

```{r}
lang + a
```

You have to use `paste()`.

The default separator is a space

```{r joinchars}
paste(lang,a)
```

You can specify other separators using `sep=''`

```{r joinchars2}
paste(lang,a,sep='')
```

## Vectors

A *vector* is an ordered group of values of the same type:

To make a vector you use a function *c*

Functions have the format e.g. *c()*, so a vector made of 1, 2, and 3 look like this:

```{r vectors}
c(1, 2, 3)
```
A vector of characters is made the same way:

```{r}
c("aaa", "bbb")
```
The built-in variable *month.name* is also a vector of strings

```{r}
month.name
```

You can refer to items in a vector by their index number. Indexes go in square brackets after the vector.

```{r}
month.name[3]
```

Use a - sign when indexing to remove items from vectors

```{r}
month.name[-2]
```

Use : to select parts of the vector

```{r}
month.name[1:3]
```

You can make a vector out of variables:
```{r}
a <- 20
b <- 19
c(a, b, b, a)
```

This is different from e.g.
```{r}
c("a", "b", "b", "a")
```

You can also use a vector as an index

```{r}
summer <- c(12, 1, 2)
month.name[summer]
```

A quick way to make sequential vectors of numbers is with :

```{r}
1:10
```

Operations on vectors act on all members of the vector:
```{r}
my_seq <- 1:5
5 * my_seq
```

Operations with two vectors work item by item:
```{r}
my_seq
my_seq + c(2,3,9,0,1)
```

Fails if the length doesn't match
```{r}
my_seq + c(2,3,9,0)
```

**Unless** one is an even multiple of the other, then is just repeats the shorter one to match:
```{r}
a <- 1:6
b <- c(0,1)
a + b
```
## Variable names

Legal variable names

1. Start with a character a-z, A-Z (case sensitive!)
2. Contain any number of further characters, numerals, or "." or "_"

Some legal variable names:
```
a
a1
a.1
a_1
aa
my.seq.1
my_seq_1
mySeq1
```

Personally, I would advise *against* using "." in variable names.  In R, this will work just fine, but in most other programming languages "." has a special meaning.  Using it a lot in R will become a bad habit if you ever try to learn another language (like Python!), and it will make your code look kind of weird to "polyglot" programmers.

Try to give your variables *meaningful names*. This makes your code easier to follow, both for yourself and others, which also makes it more *reproducible*.

## Data frame

For tabular data, like in a spreadsheet

- a table with multiple rows and columns
- every column has a single type

```{r}
participant.code <- c("a", "b", "c", "d")
sex <- c("f", "m", "f", "f")
age <- c(24, 24, 28, 27)
my.exp <- data.frame(participant.code, sex, age)
my.exp
```
You can refer to the columns using "$":
```{r}
my.exp$age
```
You can assign new columns:

```{r}
my.exp$index.number <- 1:4
my.exp
```

# Comments

Anything in a line of R code which comes after a `#` symbol is completely ignored by R, and is called a *comment*

Use comments in your R scripts to remind yourself (and inform others reading your code) of *what* your code does and *why*. This also makes your work more *reproducible*.

```{r comments}
# add an index number to preserve the order participants completed the task in
my.exp$index.number <- 1:4
my.exp
```

# Functions

```{r echo=TRUE}
sqrt(4)
```

- A *function* is a named bundle of code that we can use over and over
- Typically, functions have one or more *inputs* (called parameters or arguments)
- Typically, functions return a single *output* (called the return values)
- R has lots and lots of *built in functions*, like `sqrt` or `c`
- Learning to use the built in functions is a big part of learning any programming language

## Making a function

- R has built-in functions, but we *can make our own* too!

![](images\hypotenuse.png)

c^2 = a^2 + b^2

```{r echo=TRUE}
get_hypotenuse <- function(shortside, middleside) { 
  # shortside and middleside are the inputs (arguments)
  longside_squared<-shortside**2+middleside**2
  hypotenuse<-sqrt(longside_squared)
  return(hypotenuse) # hypotenuse is the output
}
get_hypotenuse(3,4)
```

## Make your own function!

The area of a circle is πr².

![](images\circle.PNG){width:50%}

Have a go at making an R function to calculate the area of a circle.

Hint: in R pi is `pi`

```{r answer}
circle_area<-function(radius){
  area<-pi*radius**2
  return(area)
}

circle_area(2)
```

# Libraries

- Collections of functions can be turned into *libraries* (or *packages*) and shared with other users
- R has a huge, public, online collection of libraries, called CRAN
- Using libraries others have written and shared saves you from writing functions yourself
- Just like new functions can make use of existing functions, new libraries can make use of existing libraries
- Most software is built this way, plugging together bundles of code other people have written

## Tidyverse

- The [tidyverse](https://www.tidyverse.org/) is a large collection of packages that impose a consistent design philosophy on R
- For people who have learned ‘old-fashioned’ R this counts as advanced 
- But for complete beginners it can offer a better entry point to the language
- We'll use the tidyverse extensively in this course

## During the break -- install tidyverse!

The easiest way is with `install.packages('packageName')`, for example

```
install.packages('tidyverse')
```

You can also do it via Tools -> Install Packages, or in the packages pane in the bottom right corner of RStudio (click on the 'Install' button).

You only need to install packages once, so usually I would just do this in the console rather than in a code chunk.

If installing from the menu:

- Leave the "Install from" field at the default 
- Make sure "Install dependencies" is checked
- The default "Install to library" setting on my computer makes a *global* install (all users); on the lab computer it makes a *local* install (only for you). If you have problems installing packages we might need to fix this.

## Loading Packages

To load a package enter the following (you will need to do this once each session and at the start of each script)

```{r eval=FALSE,echo=TRUE,message=FALSE}
library(tidyverse)
```

## Help function

`help()` is a function that returns information about other functions. Here's how to get help for the `read_delim` family of functions from the tidyverse:

```{r eval=FALSE,echo=TRUE}
help(read_delim)
```

- You would get the same output for e.g. `help(read_csv2)`, `help(read_delim)` etc.

- The `read_delim` functions reads data from a certain kind of file, and returns a `tibble`, the Tidyverse's version of a data frame.

- Help on `tidyverse` functions is only available if `tidyverse` is loaded

# Kelly frequency based Swedish vocabulary data

Today's sample data is the *Kelly* frequency based vocabulary list from Språkbanken

> The Swedish Kelly-list is a freely available frequency-based vocabulary list that comprises general-purpose language of modern Swedish. The list has been generated from a large web-acquired corpus (SweWAC) of 114 mln. words dating from the 2010’s. It is adapted to the needs of language learners and contains 8 425 most frequent lemmas that cover 80% of SweWAC.

Here is the [downloadable data](https://svn.spraakdata.gu.se/sb-arkiv/pub/lexikon/kelly/Swedish-Kelly_M3_CEFR.xls) of the  [Swedish Kelly-List](https://spraakbanken.gu.se/resource/kelly#tabs=information), from Språkbanken.

But if you downloaded the data.zip folder in Studiuum you should see it is already in there.

This is an Excel spreadsheet.  Sad face! :(

## About Excel...

- Excel is, generally, a bad tool for data science
- It's bad at reading and writing the most fundamental file format for tabular data, CSV
- It's especially bad for linguistics due to its refusal to enter the modern world of text encoding
- In an ideal world, I wouldn't even mention Excel in this course
- Unfortunately, lots of data is published as `.xls` files
- So it's an important real-world skill to be able to deal with this
- Don't be part of the problem, don't share your data with Excel files! Use .csv or .tsv files instead.

## Making Excel data accessible to code

- There are R packages that *might* be able to read Excel files, but it's *never* guaranteed to work
- R (and other programming languages) are always happier when processing *plain text* files like CSV (one of *many* reasons to use CSV for data science!)
- So, it's usually better to convert Excel data to a plain text format yourself, then load it in R using one of the `read_delim` functions.
- CSV (comma separated values) files are one of the most commonly used formats.
- However, if you have *commas* in any of your columns (for example, if you had a column with example sentences), then it is better to use a TSV (tab separated value) format.
- Excel can export to both csv (File > Save as type 'CSV (comma delimited)') and tsv (File > Save as type 'Text (tab delimited)') formats, but it almost always gets the encoding wrong, so it is usually a good idea to open up the csv/tsv file in notepad to check the encoding (and change it if necessary) before trying to load the data in R.

## Save excel data in csv format

Since we do not have any commas in the columns of our dataset, we can use csv format.

![](images\csvutf8.png)

If you are lucky, you will have the csv utf-8 option in excel. Older versions of excel don't have the utf-8 option, but you should be able to save it as csv, then change the encoding in Notepad.

## Open it up in Notepad

First, can you see anything wrong with how the data is formatted? (Hint: check the header row)

## Check encoding

If when you open it in notepad it doesn't say UTF-8 in the bottom right corner, do a 'save as' from notepad and select UTF-8 as the encoding. 

![](images\changeencoding.jpg)

## Loading data

We can then use `read_csv()` to load the data in R. 

You will need to save the csv file in the same place as your R notebook if you want R to be able to find it. Or, if you want to save it in a folder in your R notebook, you will need to provide R with the path to that folder when you load it. For example, `read_csv('.\\data\\Kelly.csv')`. In R, a single backslash is an escape character, and using it for directory paths will produce an error. That is why we need to use two backslashes here. The '.' at the start of the path name tells R to look in the current working directory, and then look for the folder called data. This means you don't have to write out the entire path (e.g `C:\\Users\\Bonnie\\linguistics\\data\\Kelly.csv'`).

If you run into problems, make sure that your working directory is indeed the directory where you have your .Rmd notebook. You can set the working directory to the current source file location at any time using the R menu (Session > Set Working Directory > To Source File Location). 
   
```{r load data,message=FALSE}

kelly<-read_csv('.\\data\\Kelly.csv')
```

## Exploring the data

Use `head(kelly)` to see what the first few rows of the data frame look like

```{r explore data}
head(kelly)
```

The spraakbanken website gives us the following information about each of the columns:

![](images\kellyinfo.PNG)

We can also look ourselves at what is in each column, using the `unique()` function. This shows us just unique values in a column.

```{r grammar}

unique(kelly$Grammar)
```

## A note on R ‘names’

* Legal R variable names:
    
  - a sequence of letters digits, the period and underscores; and **not** a reserved word 
  - **otherwise** must be in \`backticks\`
      
i.e. backticks are used to refer to names that are otherwise reserved or illegal
  
This is important for column names in tibbles, since they often have e.g. spaces in them

So when we look at the 'Swedish items for translation' column, we need to put it in backticks.

```{r}
unique(kelly$`Word classes`)
```

We can make this variable easier to work with by giving in a single word name, maybe WordClasses or POS. The `colnames()` function gives you a character vector of the names of the columns in a tibble. We  already learnt how to modify items in a character vector, using indexing.

While we're at it, let's also rename column 7 to something more sensible.

```{r change column name}
# change the 7th item in the colnames for the Kelly dataset to 'Item'
colnames(kelly)[8] <- 'POS'
colnames(kelly)[7] <- 'Item'
kelly
```

# Data wrangling

## Subsetting data ("filtering" rows)

Say we just want to look at the 'en' words in the data, we can do this using the `filter` function.

```{r filter}
en_words <- filter(kelly,Grammar=='en')
head(en_words)
```

## Subsetting data ("selecting" columns)

Since this dataset now only contains 'en' words, some of the columns (e.g. Grammar, Word Classes) are no longer informative. We can get rid of these unnecessary columns using `select()`.

```{r select}
en_words <- select(en_words,-(c('Grammar','POS')))
head(en_words)
```

## The pipe operator

If you want to run a whole bunch of functions on the same dataset, there is a quicker way to do this (without having to specify that dataset each time) using pipes. For example, the code we ran above to filter and then select certain parts of the kelly dataset, could also be done using the pipe operator %>% like this:

```{r pipes}
en_words <- kelly%>%
  # filter only en words
  filter(Grammar=='en')%>%
  # get rid of the columns grammar and word class as these are no longer informative
  # (all the words are en words, and all en words are nouns)
  select(-c('Grammar','POS'))
en_words
```

With the pipe operator the item on the left is ‘sent’ to the next function as its first argument.

**Keyboard shortcut**: Type `Ctrl` and `Shift` and `m`  to get ` %>% `


## Writing data files

- It is often a good idea to save intermediate data files, we can do this with `write.csv()`

```{r eval=FALSE,echo=TRUE}
write_csv(en_words, ".\\data\\en_words.csv")
```

The csv file will be saved in your current working directory if you do not specify a path.

## More ways to filter rows

![](images\subsetrows.png)


## More ways to select columns

![](images\subsetcolumns.png)


# A bare minimum introduction to plotting

- We will later learn the `tidyverse` approach to plotting in R
- To facilitate a homework exercise, today we'll get a lightning quick introduction to base R plotting
- This is done with the `plot` function.  Read `help(plot)`!
- Use `plot(x,y)` where `x` is a vector of x coordinates, and `y` is y-coords

```{r echo=TRUE}
x <- c(1,2,3,4,5)
y <- c(10,30,20,30,50)
plot(x,y)
```

# Homework exercise

Visualise frequency of verbs

- Use `filter` to limit the Kelly tibble to verbs only
- Use `select` to get just the verb IDs and frequency
- Use `write_csv` to save this to a file. By default, R includes an extra column where it assigns a label (ID) to each row, but this isn't necessary for our data because we already have our own ID column. Can you figure out how to `write_csv()` without it adding this extra column (HINT: Look at `help(write.csv)`)
- Make a plot with verb ID as x-axis and verb frequency as y-axis
- Be prepared to show: Your data file, and a R markdown notebook showing how you
  did the analysis.